# N ways to measure $\pi$
* **Author:**

* **Date:**

* **Time spent on this assignment:**

Remember to execute this cell to load numpy and pylab.
import numpy as np
import matplotlib.pyplot as plt
import math
import random
def resetMe(keepList=[]):
    ll=%who_ls
    keepList=keepList+['resetMe','np','plt','math','random']
    for iiii in keepList:
        if iiii in ll:
            ll.remove(iiii)
    for iiii in ll:
        jjjj="^"+iiii+"$"
        %reset_selective -f {jjjj}
    ll=%who_ls
    plt.rcParams.update({"font.size": 14})
    return
import datetime;datetime.datetime.now()
resetMe()

In this project we will consider three different ways of measuring $\pi$.  

<div class="alert alert-info">
Confused about what exactly you need to do?  <br />
    <b>Look for the owl emoji 🦉 for instructions</b> <br />
</div>
## Exercise 1: Series
* **List of collaborators:**

* **References you used in developing your code:**

In this exercise we will compute the value of $\pi$ using a series (a sum of bunch of terms). We will use different series which converge at different rates. 
### a. $\pi$ from $\tan$ 
Recall that we can generally find infinite series representations of transcendental functions like $\sin(x)$. In particlar

$$\tan^{-1}(x) = \sum_{n=0}^\infty \frac{(-1)^n}{2n+1} x^{2n+1} ; -1<x\leq 1$$

Since $\tan^{-1}(1) = \pi/4$, we can write the following (slowly converging) infinite series:

$$\frac{\pi}{4} = \sum_{n=0}^\infty \frac{(-1)^n}{2n+1} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + ...$$

If we group adjacent terms in the series we can rewrite this as 

$$
\begin{align}
\frac{\pi}{4} = \sum_{n=0}^\infty \frac{(-1)^n}{2n+1} &= \left(1-\frac{1}{3}\right) + \left(\frac{1}{5}-\frac{1}{7}\right) + \left(\frac{1}{9}-\frac{1}{11}\right) + ...\\
&=\frac{3-1}{3 \cdot 1} + \frac{7-5}{7 \cdot 5} + \frac{11-9}{11 \cdot 9}+...\\
&=\frac{2}{3}+ \frac{2}{35}+\frac{2}{99} + ...\\
&= \boxed{2 \cdot \sum_{n=0}^\infty \left[ \frac{1}{(4n+3)(4n+1)} \right]}
\end{align}
$$

The value of $\pi$ is $3.14159265358979323846264338327950288419716939937510582...$ though the precision with which your computer can calculate it is probably limited to fewer digits than this.

🦉Please write a Python script that calculates an approximation to $\pi$ using the arctan series **i.e. the boxed formula**, and compare its accuracy after the $n = 10$ term, 100 term, 10,000 term, and 1,000,000 term.

There are two ways to approach this.  One of these is by writing a loop (use a conditional statement to print something after the appropriate terms): 

Start by initializing a few things, then executing a loop that calculates the nth term, with n running from 0 to 999,999, summing the terms as you go.
The other option is to write this in a line or two using list comprehensions. 

Let us start with a loop.
<div class="alert alert-warning">
<b>Do not use the word <code>sum</code> as a variable!</b> <br />Notice how <code>sum</code> is green in a cell - this means it is a special keyword.<br /> 
</div>
*Write your for loop computing the difference from $\pi$ for a given term in the series below*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>

# ANSWER ME
N = [10]
value_of_pi= []
for n in N:
    S=0
    for i in range(n):
        S+=(1/((4*i+3)*(4*i+1)))
    value_of_pi.append(8*S)
    print('Difference for n =  10 is', math.pi-S) #Difference for n = 10

print('pi value for = 10 is', value_of_pi) #Value of pi for n = 10

N = [100]
value_of_pi= []
for n in N:
    S=0
    for i in range(n):
        S+=(1/((4*i+3)*(4*i+1)))
    value_of_pi.append(8*S)
    print('Difference for n =  100 is', math.pi-S) #Difference for n =  100

print('pi value for =  100 is', value_of_pi) #Value of pi for n = 100


N = [1000]
value_of_pi= []
for n in N:
    S=0
    for i in range(n):
        S+=(1/((4*i+3)*(4*i+1)))
    value_of_pi.append(8*S)
    print('Difference for n =  1000 is', math.pi-S) #Difference for n =  1000

print('pi value for =  1000 is', value_of_pi) #Value of pi for n = 1000


N = [1000000]
value_of_pi= []
for n in N:
    S=0
    for i in range(n):
        S+=(1/((4*i+3)*(4*i+1)))
    value_of_pi.append(8*S)
    print('Difference for n =  1000000 is', math.pi-S) #Difference for n =  1000000

print('pi value for =  1000000 is', value_of_pi) #Value of pi for n = 1000000

print('References:  https://www.geeksforgeeks.org/calculate-pi-with-python/, https://www.purplefrogsystems.com/blog/2020/03/creating-a-python-function-to-calculate-pi/')
    

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>

### b. List Comprehensions
We'll now look deeper at the terms in the series above, in order to practice plotting and analyzing data.

Recall that we can store items into a list. A very useful feature about a list is that it can be variable length!
To initialize a new list we use `[]`, and can add to it by using the `append()` function
myList = []
myList.append(10)
print(myList)
print("myList is length",len(myList))
This is obviously most useful in a `for` loop, where we can append numbers to the list.
myList = [] #don't forget to reset it!
for i in range(0,5):
    myList.append(i+5)
print(myList)
print("myList is length",len(myList))
We'll want to plot some lists in a moment. Plotting things in python uses the matplotlib package, imported as `plt`. There are two basic steps for plotting:
* `plt.plot(x,y)`
    * This tells matplotlib to plot the lists or arrays `x` and `y`. You can also add instructions on how it should look after x,y. If we wanted a dashed line we can use `plt.plot(x,y,'--')` or if we want square points we can use `plt.plot(x,y,'s')`
* `plt.show()` 
    * This tells matplotlib you're done drawing/adding data and to render the image
#if we add '--' it will be dashed, and if we add 's' there will be squares. What if we do both?
plt.plot(range(0,5),myList)
plt.xlabel("My x Label")
plt.ylabel("My y Label")
plt.title("Title of the coolest plot")
plt.show()
🦉Now write code to make two lists, one of each term
$$
\frac{1}{(4n+3)(4n+1)}
$$
in the $tan^{-1}$ series above (you can include the factor of 8 if you like), and another indexing which term it is (you may start numbering at 0 to make it easy). Do this for 100,000 terms.   
You'll probably find that the terms in the series look pretty boring. That's because they get small really fast! To see them a little better we can adjust the y-axis to be scalled *logrithmically* rather than *linearly*, by calling `plt.yscale('log')`. (This will be explored later in the course!)
*Write your code (and generate your plot) below.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>


#ANSWER ME

my_list = [] 
x = []   
N = 100000
for n in range(N): 
    x.append(n)
    my_list.append(1/((4*n+3)*(4*n+1))) 



plt.plot(range(N), my_list)    # plot the sequences
plt.yscale('log')   # set the y scale to logarithmic
plt.title('x vs log(y)')    # set the title
plt.xlabel('x')   # set the x label
plt.ylabel('log(y)')   # set the y label
plt.show()       # show the plot
    

 
 
    


<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
### c. $\pi$ from Ramanujan
A much more rapidly converging series was discovered by the brilliant Indian mathematician Srinivasa Ramanujan.  It is

$$\frac{1}{\pi} = \frac{2\sqrt{2}}{9801} \sum_{k=0}^\infty \frac{(4k)!(1103+26390k)}{(k!)^4396^{4k}}$$

where $k!$ ("k factorial") is $1\times 2\times 3\times ... \times k$ and $(4k)!$ is $1\times2\times3\times ... \times 4k$

🦉Write a Python script that calculates an approximation to $\pi$ using the Ramanujan series, and comment on its accuracy after 1, 2, and 3 terms. (Recall that the value of $\pi$ is 3.14159265358979323846264338327950288419716939937510582...)

Note that there are even faster-converging formulas than this! One, mentioned in Wolfram MathWorld[<sup>1</sup>](#fn1), adds 50 digits of precision for each additional term.

*Please put your loop showing your approximation to $\pi$ below.  To see how close you are to $\pi$ one thing you can do is to measure `-np.log(np.abs(ans-np.pi))`.  This measures the difference from $\pi$ and then converts this difference to a logarithm so large numbers are very close.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>

# ANSWER ME
A=0 
for i in range(3): 
  A+=((math.factorial(4*i))*(1103+26390*i))/((math.factorial(i)**4) * 396**(4*i)) 
  print(f' n={i+1} , A={1/((2*math.sqrt(2)/9801)*A)}') 
  ans = 1/((2*math.sqrt(2)/9801)*A)
  print(f'n={i+1} term, the difference is: {-np.log(np.abs(ans-np.pi))}')
  #print(f'n={i+1} term, the difference is: {-np.log(np.abs(ans-np.pi))}')
print("References: https://arivukalanjiam.wordpress.com/2017/08/02/ramanujans-formula-for-pi-python-code/, https://www.greenteapress.com/thinkpython/code/pi.py")
    
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>

## Exercise 2: Archimedes
* **List of collaborators:**

* **References you used in developing your code:**
Archimedes was an ancient greek who lived in 287 BC ([wikipedia](https://en.wikipedia.org/wiki/Archimedes)).  He developed a way to approximate $\pi$ by estimating the circumference of the circle $C$ of known radius $r$ by a series of polygons inscribed within the circle.  Once we know the circumference, $C=2\pi r$ and therefore $\pi = C/(2r)$.   

**Note:** don't worry about using $\pi$ in your code below!
### a. Drawing a circle
🦉Start by defining a function `DrawCircle()` which plots a circle (but don't call `plt.show()` at the end of it.)  You can then generate your circle by doing

```
DrawCircle()
plt.axis('scaled') # this makes your circle look like a circle and not an oval
plt.show()
```

Recall that the for a circle of radius $r$,

$x=r\cos\theta \hspace{2cm} y=r\sin\theta$

where $0 \leq \theta \leq 2\pi$. Plot all points starting with $\theta=0$ with increments of $d\theta=0.0001$ until you get to $2\pi$.   In this problem, we will work with a circle of radius $r=1$.  

*Draw your circle below!*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>

# ANSWER ME


def DrawCircle ():
    theta = 0
    change_in_theta = 0.0001
    radius = 1
    x = []
    y = []
    while theta <= 2 * math.pi:
        x.append(math.cos (theta))
        y.append(math.sin (theta))
        theta += change_in_theta
    plt.plot (x, y)

DrawCircle ()    
plt.axis ('scaled')
plt.show ()

#References:
#https://www.geeksforgeeks.org/how-to-draw-a-circle-using-matplotlib-in-python/
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>

### b. Drawing a polygon
🦉Now that you can draw a circle, the next step is to draw a polygon inside the circle.  Write a function `DrawPolygon(N)`. The points of a $N$-sided polygon should be at angles $2\pi/N$.  You should add an extra point at the end so your polygon looks closed. 

Use your function to draw a 5-sided polygon (after drawing the circle):
```
DrawCircle()
DrawPolygon(5)
plt.show()
```
*Write below your function to draw a $N$ sided polygon and then use it to draw a 5-sided polygon.  You can use* `dTheta = 2*np.pi/N` *in your function.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER ME
def DrawPolygon(N):
    theta = 0
    
    dTheta = 2*np.pi/N

    for i in range(N):

        plt.plot(radius*np.cos(theta), radius*np.sin(theta), marker='o')

        theta += dTheta
    

DrawCircle()
DrawPolygon(5)

plt.show()
def Polygon1(N):
    for i in range(N):
        dTheta = 2*np.pi/N
        x = np.cos(dTheta)
        y = np.sin(dTheta)
        plt.plot(x,y)
    return x, y
DrawCircle()
Polygon1(5)
plt.axis ('scaled')
plt.show()
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>

### c. Python Fun - List Comprehensions 
A cool Python feature is list comprehensions. Instead of writing a `for` loop, if we're clever we can stuff everything into one line inside a list, and python will be able to fill out the list faster than doing an `append()`.  
Check out the example below:
slowList = []
for i in range(0,5):
    slowList.append(i-5)
# now we rearrange the syntax, so what we want each element to be
# is *first* and the for loop statement is after
fastList = [i-5 for i in range(0,5)]
print("slowList=",slowList)
print("fastList=",fastList)
🦉Try rewriting your answer to **b.** to use list comprehensions, turning any `for` loops you had into one line. At the end of the day, you'll want a line that generates your `x` points and another that has your `y` points, for example. 

*Optional:* In addition, you could turn your perimeter code into one line, by making a list of distances and summing them all using `np.sum`. Don't worry about this for now, you'll get plenty of practice later!
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# answer here!


def Polygon2(N):
    x = [np.cos(2*np.pi*i/N) for i in range(N)]
    y = [np.sin(2*np.pi*i/N) for i in range(N)]
    return x, y
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>

🦉Modify your function above to return the perimeter of the polygon that you drew. Now make a plot of the estimate of $\pi$ ($C/2$) from a $N$-sided polygon as a function of $3<N<100$.   

How close is your answer to $\pi$ for $N=100$?

*Have your function return the perimeter of your polygon which should be an approximation of $2\pi$.  You can copy it from above or just change the above function (and call it down here).  Also include your code (and plot) that shows how far you are from $\pi$.  You might want to use `plt.axhline(np.pi,linestyle='--')` to draw a line where $\pi$ is on your plot.  Also include below how close you get for $N=100$.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER HERE

def Polygon2(N):
    x, y = polygon(N)
    for n in range(N):
        d = np.sqrt((x[n]-x[i-n])**2 + (y[n]-y[n-1])**2)
    return np.sum(d)


#N = np.arange(3, 100)


perim = [perimeter(i) for i in range(3,100)]


plt.plot(N, perim)
plt.axhline(np.pi, linestyle='--')
plt.xlabel('N')
plt.ylabel('Perimeter')
plt.title('Perimeter of a polygon with N number of sides')
plt.show()


print('The perimeter of a 100-sided polygon is', perimeter(100))


print('The difference between the perimeter and pi is', np.abs(perimeter(100)-np.pi))
print("References: https://www.tutorialspoint.com/program-to-find-perimeter-of-a-polygon-in-python")
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
### d.  Inscribed Polygon (EC) (Extra Credit: 5 points)
Do the same thing you did earlier but use both the inscribed and circumscribed polygons.  Show that you approach $\pi$ from above and below. 
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER HERE
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
## Exercise 3: Throwing Darts
* **List of collaborators:**

* **References you used in developing your code:**
In this exercise, we will compute $\pi$ by (*in silico*[<sup>2</sup>](#fn2)) throwing darts at a board.  To do this,  we are going to need to use random numbers.
You can read about Python’s (pseudo)random number generating functions here: https://docs.python.org/3/library/random.html. They live in the `random` library, and can be imported using `import random`. Here’s a snippet of code that generates a sequence of random numbers between -1 and 1.

import random
for i in range(1,10):
    print(random.uniform(-1,1))
A couple of fine points: `uniform(-1,1)` generates random numbers with a uniform distribution in the semi-open range `[-1.0,1.0)`;  the `range` specification in the for loop requires i to be greater than or equal to 1, but less than 10. Only nine random numbers are printed.
### a. Darts at a board
🦉Draw a a $1 \times 1$ square with a circle of radius 0.5 within it. Then pick 25 random points $(x,y)$ in the square (do this by picking two random numbers each between -1 and 1). Plot them within the square (`plt.plot(x,y,'.',color='red'`).   Recall that the area of a circle is $\pi r^2$, and that if you inscribe a circle of radius 0.5 inside a square of side length 1, the ratio of the areas of the circle and square will be $\pi$/4.
$$\frac{\pi r^2}{4 r^2}= \frac{\pi}{4}$$

Because the dart is likely to hit any place on the square, the fraction of dots within the circle is the ratio of the area between the circle and the square.


I removed all the axis to make them look prettier by doing:
```python
plt.xlim(-1,1)
plt.ylim(-1,1)
plt.gca().get_xaxis().set_visible(False)
plt.gca().get_yaxis().set_visible(False)
plt.show()
```

*Code below for circle and random points in a square.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER HERE

circle = plt.Circle((0.0, 0.0), 0.5)
plt.gca().add_patch(circle)

for i in range(25):
    x = np.random.random() *1 - 0.5
    y = np.random.random() *1 - 0.5
    plt.plot(x,y,'.',color='red')

plt.xlim(-0.5,0.5)
plt.ylim(-0.5,0.5)   
plt.gca().get_xaxis().set_visible(False)
plt.gca().get_yaxis().set_visible(False)
plt.show()

#References:
#https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.add_patch.html
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
### b. $\pi$ from Darts
🦉Within your loops, measure the fraction of dots that actually end up in your circle.  Measure $\pi$ using this number both with 25 dots as well as 2500 dots (for this latter number you might want to turn off the plotting or it will be really slow). 
*Code for fraction of points which are in the circle.  This should be $\pi/4$ so multiply by 4 to get $\pi$*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER HERE
in_circle = 0
n1 = 25
for i in range(n1):
    x = np.random.random() *1 - 0.5
    y = np.random.random() *1 - 0.5
    if x**2 + y**2 <= 0.5**2:
        in_circle += 1

pi_approx = (in_circle/n1) * 4       
print(f"Approximate value of pi for {n} dots: {pi_approx}")

# approximating for 2500 dots
in_circle = 0
n2 = 2500
for i in range(n2):
    x = np.random.random() *1 - 0.5
    y = np.random.random() *1 - 0.5
    if x**2 + y**2 <= 0.5**2:
        in_circle += 1

pi_approx = (in_circle/n2) * 4       
print(f"Approximate value of pi for {n} dots: {pi_approx}")
print('References: ')
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
### c. Repeated Experiments
🦉Now wrap your code in an additional outer loop which runs 1000 times. You now have an outer loops (1000 times) and inner loop (2500 times).   You are now estimating $\pi$ 1000 times.  

Store each of the estimates in an array (or list) and generate a histogram (bar graph) of the values in the array using `plt.hist`. If my estimates were stored in a list named `storedVals` I can generate a histogram by
```python
plt.hist(storedVals)
#...add axis labels, etc here...
plt.show()
```

Finally increase the number of iterations in your inner loop from 2,500 to 10,000. How does the RMS width of your histogram change?  
(You should find that it is about half as big. It is very common for statistical precision to improve proportional to the square root of the number of samples in your average.)

*Run your function to get $\pi$ many times and make a histogram of your answers below.*

<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsStart.svg" width=200 align=left></img><br>
# ANSWER HERE
for i in range(1000):
    storedVals = []
    in_circle = 0
    n1 = 25
    for i in range(n1):
        x = np.random.random() *1 - 0.5
        y = np.random.random() *1 - 0.5
        if x**2 + y**2 <= 0.5**2:
            in_circle += 1

    pi_approx = (in_circle/n1) * 4
    storedVals +=  pi_approx
    print(f"Approximate value of pi for {n} dots: {pi_approx}")
plt.hist(storedVals)
plt.show()
<img src="https://courses.physics.illinois.edu/phys246/fa2022/img/AnsEnd.svg" width=200 align=left></img><br>
## Exercise 4: Buffon's Needle (EC) (Extra Credit: 10 points)
* **List of collaborators:**

* **References you used in developing your code:**
Read about Buffon's needle and implement a simulation of it to get $\pi$.
**Acknowledgements:** 
* Ex. 1,3 originally developed by George Gollin
* Ex. 2 developed by Bryan Clark

© Copyright 2022
<span id=“fn1”><sup>1</sup>http://mathworld.wolfram.com/PiFormulas.html </span>

<span id=“fn2”><sup>2</sup>performed by computer simulation; by silicon</span>
self.x = float(x)  #width of the needle
self.y = float(y)  #witdh of the space
self.r = [] #coordinated of the centre of the needle
self.z = []

def samples(self):
    # throwing the needles
    for i in range(self.n):
        self.r.append(np.random.uniform(0,self.y))
        
        
print("References: ")

